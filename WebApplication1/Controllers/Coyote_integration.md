For reusing the TestOutputLogger, instead of trying to inject from the unit test package of Coyote (which I don't publish on NuGet anyways ), I can add a new attribute to the Coyote.Test package, something like [Microsoft.Coyote.Rewriting.Skip], then we can add it to the TestOutputLogger class definition in your test project, and Coyote when doing rewriting will check for this attribute and ignore the class! So no more weird stackoverflow errors 

I feel trying to do replay programmatically through the TestEngine API (by reading the contents of the trace file and then feeding to the Configuration.WithReproducibleTrace (which will then use the decisions in the file to do exploration, basically replaying the bug!), it might be much more convenient to use the "coyote replay" tool as you were attempting. I feel this might be more natural, cause (1) its a pain to have to setup a way to pass the trace every time to the test DLL and then run replay+debug from there, and (2) this will happen only occasionally (when a bug is hit and someone wants to replay it) rather than all the time or on CI (where the programmatic approach helps). The tricky part is that I need to make the coyote tool to be able to load the method to replay (currently an xUnit method), but I think I have some ideas here, and I might be able to make it work if we follow certain test declaration patterns (rather than expecting it to work for arbitrary tests).

Would love to hear your thoughts and if you have any other ideas (but please no rush!). If our thinking aligns, I will make time next week to try implement these so we can hopefully have easy way to replay 